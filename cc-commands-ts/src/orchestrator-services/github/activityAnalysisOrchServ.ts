/**
 * @file GitHub Activity Data Collection Orchestrator Service
 * 
 * Orchestrator service for collecting mathematical facts about project activity.
 * Coordinates fact collection, aggregation, and provides comprehensive data
 * for LLM analysis and interpretation.
 * 
 * CRITICAL: This service collects ONLY mathematical facts. All analysis,
 * interpretation, and insights are generated by the LLM.
 */

import { OrchestratorError } from '../../core/error/OrchestratorError.js'
import { LLMInfo } from '../../core/LLMInfo.js'
import { IActivityAnalysisArgs } from './types/ArgumentTypes.js'
import { TActivityAnalysisServices } from './types/ServiceTypes.js'
import { safeArrayAccess } from './utils/TypeGuards.js'

/**
 * Activity Data Collection Orchestrator Service
 * 
 * This orchestrator service coordinates comprehensive fact collection
 * across multiple repositories. It provides raw mathematical data and
 * metrics for LLM analysis and interpretation.
 * 
 * @param args - Typed arguments with repositories, owner, and time window
 * @param services - Activity analysis services (repository, activity, auth)
 * @returns LLMInfo with mathematical facts and comprehensive LLM instructions
 */
export const activityAnalysisOrchServ = async (
  args: IActivityAnalysisArgs,
  services: TActivityAnalysisServices
): Promise<LLMInfo> => activityAnalysisOrchServImpl(args, services)

/**
 * Implementation of activity analysis orchestrator service
 */
async function activityAnalysisOrchServImpl(
  args: IActivityAnalysisArgs,
  services: TActivityAnalysisServices
): Promise<LLMInfo> {
  const result = LLMInfo.create()
  
  try {
    // Use typed arguments directly
    result.addData('ANALYSIS_OWNER', args.owner)
    result.addData('ANALYSIS_TIME_WINDOW_DAYS', String(args.timeWindowDays))
    result.addData('ANALYSIS_REPOSITORIES_COUNT', String(args.repositories.length))
    result.addData('ANALYSIS_REPOSITORIES_LIST', args.repositories.join(', '))
    
    // Calculate analysis date range
    const endDate = new Date()
    const startDate = new Date(endDate.getTime() - (args.timeWindowDays * 24 * 60 * 60 * 1000))
    result.addData('ANALYSIS_START_DATE', startDate.toISOString())
    result.addData('ANALYSIS_END_DATE', endDate.toISOString())
    
    // Validate authentication
    result.addAction('Validate authentication for activity analysis', 'success')
    const token = await services.authService.getGitHubToken()
    const authenticatedUser = await services.authService.getAuthenticatedUser(token)
    result.addAction('Validate authentication for activity analysis', 'success', `Authenticated as ${authenticatedUser}`)
    result.addData('AUTHENTICATED_USER', authenticatedUser)
    
    // Collect activity data from all repositories
    result.addAction('Aggregate activity across repositories', 'success')
    
    const aggregatedActivity = await services.activityService.aggregateActivityAcrossRepos(
      args.repositories,
      args.owner,
      startDate
    )
    
    result.addAction('Aggregate activity across repositories', 'success', 
      `Analyzed ${aggregatedActivity.repositoriesCount} repositories`)
    
    // Add aggregated activity data to result
    result.addDataBulk(aggregatedActivity.toLLMData())
    
    // Calculate activity summary
    result.addAction('Calculate activity summary', 'success')
    
    const activitySummary = await services.activityService.calculateActivitySummary([aggregatedActivity])
    
    result.addAction('Calculate activity summary', 'success', 
      `Generated summary with commits-to-issues ratio: ${activitySummary.commitsToIssuesRatio}`)
    
    // Add summary data to result  
    const summaryData = activitySummary.toLLMData()
    for (const [key, value] of Object.entries(summaryData)) {
      result.addData(`SUMMARY_${key}`, value)
    }
    
    // Identify most active repositories
    result.addAction('Identify most active repositories', 'success')
    
    const mostActiveRepos = await services.activityService.identifyMostActiveRepositories([aggregatedActivity])
    
    result.addAction('Identify most active repositories', 'success', 
      `Ranked ${mostActiveRepos.length} repositories by activity`)
    
    result.addData('MOST_ACTIVE_REPOSITORIES', mostActiveRepos.slice(0, 5).join(', '))
    result.addData('TOP_REPOSITORY', safeArrayAccess(mostActiveRepos, 0) ?? 'None')
    
    // Add mathematical facts for LLM analysis
    result.addData('AVERAGE_DAILY_ACTIVITY', String(aggregatedActivity.getAverageDailyActivity()))
    result.addData('COMMITS_PER_DAY', String(aggregatedActivity.avgCommitsPerDay))
    result.addData('ISSUES_PER_DAY', String(aggregatedActivity.avgIssuesPerDay))
    result.addData('PRS_PER_DAY', String(aggregatedActivity.avgPrsPerDay))
    
    // Repository coverage metrics
    result.addData('REPOSITORIES_ANALYZED', String(aggregatedActivity.repositoriesCount))
    result.addData('HAS_COMMIT_DATA', String(aggregatedActivity.commitsCount > 0))
    result.addData('HAS_ISSUE_DATA', String(aggregatedActivity.totalIssuesCount > 0))
    result.addData('HAS_PR_DATA', String(aggregatedActivity.totalPrsCount > 0))
    result.addData('HAS_CONTRIBUTOR_DATA', String(aggregatedActivity.contributorsCount > 0))
    
    // Comprehensive LLM Instructions for Analysis
    result.addInstruction('ANALYZE the mathematical activity data and generate insights about:')
    result.addInstruction('1. PROJECT VELOCITY: Interpret commits-to-issues ratio, daily activity patterns')
    result.addInstruction('2. DEVELOPMENT PATTERNS: Analyze commit frequency, PR merge rates, issue resolution')
    result.addInstruction('3. TEAM DYNAMICS: Interpret contributor distribution, collaboration patterns')
    result.addInstruction('4. PROJECT HEALTH: Assess based on activity consistency, issue management')
    result.addInstruction('5. REPOSITORY DISTRIBUTION: Identify most/least active repositories and significance')
    result.addInstruction('PROVIDE specific recommendations based on the mathematical ratios and patterns')
    result.addInstruction('HIGHLIGHT concerning patterns (low ratios, declining activity, bottlenecks)')
    result.addInstruction('SUGGEST improvements based on the data (more contributors, better issue flow, etc.)')
    result.addInstruction('ADAPT analysis depth based on data completeness and repository coverage')
    result.addInstruction('INCLUDE confidence levels based on data quality and time window coverage')
    
    return result
    
  } catch (error) {
    if (error instanceof OrchestratorError) {
      result.setError(error)
    } else {
      result.setError(new OrchestratorError(
        error instanceof Error ? error : new Error(String(error)),
        [
          'Verify all repositories exist and are accessible',
          'Check if the time window is reasonable (1-365 days)',
          'Ensure you have read access to all specified repositories',
          'Consider reducing the number of repositories if rate limits are hit'
        ],
        { 
          error: error instanceof Error ? error.message : String(error),
          owner: args.owner,
          repositories: args.repositories,
          timeWindowDays: args.timeWindowDays 
        }
      ))
    }
    
    return result
  }
}
